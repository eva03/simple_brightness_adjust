#!/usr/bin/env /usr/bin/python3
"""
Brightness control utility for external monitors.

Controls monitor brightness via DDC/CI using ddcutil.
Monitors are sorted alphabetically by stable ID (manufacturer-model-serial)
and assigned to slots 1, 2, 3... deterministically based on which monitors
are currently connected.
"""

import argparse
import sys
from pathlib import Path

# Add lib directory to Python path (works both from repo and installed location)
SCRIPT_DIR = Path(__file__).parent
LIB_DIR = SCRIPT_DIR.parent / 'lib' / 'brightness-control'
sys.path.insert(0, str(LIB_DIR))

from monitor_detector import detect_monitors
from ddcutil_wrapper import get_brightness, set_brightness, MonitorCache


BRIGHTNESS_STEP = 10
MIN_BRIGHTNESS = 0
MAX_BRIGHTNESS = 100
CACHE_DURATION = 60  # seconds


def get_sorted_monitors(cache: MonitorCache):
    """Return sorted monitor list, using cache if fresh."""
    cached = cache.get()
    if cached is not None:
        return cached

    monitors = detect_monitors()
    cache.set(monitors)
    return monitors


def adjust_brightness(monitor_slot: int, action: str) -> None:
    cache = MonitorCache(cache_duration=CACHE_DURATION)
    monitors = get_sorted_monitors(cache)

    if monitor_slot > len(monitors) or monitor_slot < 1:
        slot_list = "\n".join(
            f"  {i+1}: {m.stable_id}" for i, m in enumerate(monitors)
        )
        raise RuntimeError(
            f"Monitor slot {monitor_slot} not available. "
            f"Detected {len(monitors)} monitor(s):\n{slot_list}"
        )

    monitor = monitors[monitor_slot - 1]

    try:
        current = get_brightness(monitor.i2c_bus)
    except RuntimeError:
        # Cache may be stale (monitor reconnected on different bus) â€” re-detect
        cache.invalidate()
        monitors = detect_monitors()
        cache.set(monitors)
        if monitor_slot > len(monitors):
            raise RuntimeError(
                f"Monitor slot {monitor_slot} not available after re-detection"
            )
        monitor = monitors[monitor_slot - 1]
        current = get_brightness(monitor.i2c_bus)

    if action == 'up':
        new_brightness = min(current + BRIGHTNESS_STEP, MAX_BRIGHTNESS)
    else:
        new_brightness = max(current - BRIGHTNESS_STEP, MIN_BRIGHTNESS)

    if new_brightness != current:
        set_brightness(monitor.i2c_bus, new_brightness)


def show_monitors() -> None:
    """Re-detect monitors and print current slot assignments."""
    cache = MonitorCache(cache_duration=CACHE_DURATION)
    cache.invalidate()

    try:
        monitors = detect_monitors()
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    cache.set(monitors)

    if not monitors:
        print("No monitors detected.")
        return

    print(f"Found {len(monitors)} monitor(s):\n")
    for i, monitor in enumerate(monitors, start=1):
        up_key = f"Super+Shift+F{(i * 2) - 1}"
        down_key = f"Super+Shift+F{i * 2}"
        print(f"Slot {i}: {monitor.manufacturer} {monitor.model}")
        print(f"   Stable ID : {monitor.stable_id}")
        print(f"   I2C bus   : {monitor.i2c_bus}")
        print(f"   Shortcuts : {up_key} (up), {down_key} (down)\n")


def main():
    parser = argparse.ArgumentParser(
        description='Control external monitor brightness via DDC/CI',
        epilog='Example: brightness-control -m 1 -a up'
    )
    parser.add_argument(
        '-m', '--monitor',
        type=int,
        metavar='SLOT',
        help='Monitor slot number (1, 2, ...)'
    )
    parser.add_argument(
        '-a', '--action',
        choices=['up', 'down'],
        help='Brightness adjustment direction'
    )
    parser.add_argument(
        '--detect',
        action='store_true',
        help='Re-detect monitors, update cache, and show slot assignments'
    )

    args = parser.parse_args()

    try:
        if args.detect:
            show_monitors()
        elif args.monitor and args.action:
            adjust_brightness(args.monitor, args.action)
        else:
            parser.print_help()
            sys.exit(1)

    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        sys.exit(130)
    except PermissionError as e:
        print(f"Permission Error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
